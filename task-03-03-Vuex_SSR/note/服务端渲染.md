# 服务端渲染
## 概述
### 基于客户端渲染的前端框架
- Angular
- React
- Vue

### SPA 单页应用
- 优点
    - 用户体验好
    - 开发效率高
    - 渲染性能好
    - 可维护性
- 缺点
    - 首屏渲染时间长
    - 不利于SEO

### 借鉴传统的服务器渲染
![](./images/借鉴传统的服务器渲染.jpg)

### 客户端激活为SPA
![](./images/客户端激活为SPA.jpg)

### 同构应用
- 通过服务端渲染首屏直出，解决SPA应用首屏渲染慢以及不利于SEO问题
- 通过客户端渲染结果页面内容交互得到更好的用户体验
- 这种方式通常称之为现代化的服务端渲染，也叫同构渲染
- 这种方式构建的应用称之为服务端渲染应用或者是同构应用

## 传统的服务端渲染
- Web 页面渲染都是在服务端完成的，即服务端运行过程中将所需的数据结合页面模板渲染为HTML，响应给客户端浏览器
- 缺点：
    - 前后端代码完全耦合在一起，不利于开发和维护
    - 前端没有足够发挥空间
    - 服务端压力大
    - 用户体验一般
- 基于 node.js 实现简单的服务端渲染
    - 安装依赖
        - 创建 http 服务 npm i express 
        - 服务端模板引擎 npm i art-template express-art-template
```
// 服务端代码
const express = require('express') 
const fs = require('fs') 
const template = require('art-template') 
const app = express()

app.get('/', (req, res) => {
    // 1. 得到模板内容 
    const templateStr = fs.readFileSync('./index.html', 'utf-8')

    // 2. 得到数据 
    const data = JSON.parse(fs.readFileSync('./data.json', 'utf-8'))

    // 3. 渲染：数据 + 模板 = 完整结果 
    const html = template.render(templateStr, data)

    // 4. 把渲染结果发送给客户端 
    res.send(html)
})

app.listen(3000, () => console.log('running...'))

// 客户端代码
<!DOCTYPE html> 
<html lang="en"> 
    <head> 
        <meta charset="UTF-8" /> 
        <title>Document</title> 
    </head> 
    <body> 
        <h1>{{ message }}</h1> 
        <ul>
            {{ each todos }} 
            <li>{{ $value.title }}</li> 
            {{ /each }} 
        </ul> 
    </body> 
</html>
```

## 客户端渲染
- 可以把【数据处理】和【页码渲染】这两件事儿分开了，也就是【后端】负责数据处理，【前端】负责页面渲染，这种分离模式极大的提高了开发效率和可维护性
- 缺点：
    - 首屏渲染慢：因为 HTML 中没有内容，必须等到 JavaScript 加载并执行完成才能呈现页面内容
        - 客户端渲染至少发起Http请求三次，第一次是请求页面，第二次是请求页面里的JS脚本，第三次是动态数据请求
    - 不利于 SEO：同样因为 HTML 中没有内容，所以对于目前的搜索引擎爬虫来说，页面中没有任何有用的信息，自然无法提取关键词，进行索引了
        - 客户端渲染的内容都是由JS生成的，而搜索引擎只会请求网络路径的html，不会去将html里的JS脚本再去请求做解析处理，因此搜索引擎获取到的首屏是空的，单页应用SEO几乎为0

### 现代化的服务端渲染（同构渲染）
#### 同构渲染 = 后端渲染 + 前端渲染
- 基于React、Vue等框架，客户端渲染和服务端渲染的结合
    - 在客户端执行一次，用户实现服务器端渲染（首屏直出）
    - 在客户端再执行一次，用于接管页面交互
- 核心解决 SEO 和首屏渲染慢的问题
- 拥有传统服务端渲染的优点，也有客户端渲染的优点

### 同构渲染应用的问题
- 开发条件有限
    - 浏览器特定的代码只能在某些生命周期钩子函数中使用
    - 一些外部扩展库可能需要特殊处理才能在服务端渲染应用中运行
    - 不能再服务端渲染期间操作DOM
    - 某些代码操作需要区分运行环境
- 涉及构建设置和部署的更多要求
    - 构建：客户端渲染 --> 仅构建客户端应用即可，同构渲染 --> 需要构建两个端
    - 部署：客户端渲染 --> 可以部署在任意 Web 服务器中，同构渲染 --> 只能部署在 Node.js server 运行环境中
- 更多的服务器端负载
    - 在 Node 中渲染完整的应用程序，相比仅仅提供静态文件服务器，需要大量占用CPU资源
    - 如果应用在高流量环境下使用，需要准备相应的服务器负载
    - 需要更多的服务端渲染优化工作处理