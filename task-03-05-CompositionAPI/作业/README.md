## Vue 3.0 性能提升主要是通过哪几方面体现的？

首先vue3使用monorepo来管理模块。monorepo简单来说就是把项目每个模块当成包来管理，每个模块有自己的package.json，因此导入vue3不用整个包导入，而是可以根据需要把不同模块导入。

源码体积方面，vue3把冷门的api删除，还有引入tree-shaking，即通过编译阶段的静态分析，找到没有引入的模块并打上标记，在打包时删除标记部分。

除此之外，在响应式数据处理方面，使用proxy取代object.defineProperty，前者代理的是整个对象，性能更好，而且vue3不像vue2般，看到嵌套对象，直接无脑递归转换成响应式对象，而是等到用户真正访问嵌套对象，才真正转成响应式。

还有就是优化编译和diff算法，减少不必要的比较。

## Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？

Options Api就是直接描述组件选项的对象，如在vue中，把描述组件分为data，methods等，开发者直接在相应部分写代码就可以了。然而，随着组件逻辑越来越複杂，Options Api使得代码看起来非常混乱

Composition Api就解决了这个问题，它的思想是把组件逻辑封装成函数，这样做的好处一是管理非常方便，把不同逻辑分成不同的函数，二是封装成函数后，可以複用，也解决了Vue2的mixin数据源不清晰问题。



## Proxy 相对于 Object.defineProperty 有哪些优点？

Proxy是在目标对象前增加了一层 "拦截"，但又不改变对象本身，而Object.defineProperty是会修改对象的。Proxy监听对象本身，而且可以监听数组，解决了vue2中数组的length修改是不会响应等问题，利用Proxy来写响应式部分代码可以更简单，而且性能更好。

## Vue 3.0 在编译方面有哪些优化？

Vue 3.0通过在编译阶段优化编译的结果，来实现运行时 patch 过程的优化，即在对比新旧vnode优化。

Vue.js 3.0 做到了，它通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破，我会在后续的章节详细分析它是如何实现的。

除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法，
